"use server";

import {
  getInventoryMovementFilterOptions,
  type InventoryMovementWithRelations,
  listInventoryMovements,
} from "@/data/repositories/inventory.movements.repository";

export type MovementOperation = "ingreso" | "salida";

export type InventoryMovementDTO = {
  id: string;
  consecutivo: number;
  typeId?: string;
  typeName: string;
  operation: MovementOperation;
  productId?: string;
  productLabel: string;
  quantity: number;
  unitCost: number;
  totalCost: number;
  pvp?: number;
  imeis: string[];
  createdAt: string;
  updatedAt: string;
  createdBy?: string;
  bodegaNombre?: string;
  proveedorNombre?: string;
  ventaConsecutivo?: number;
  clienteNombre?: string;
  comentario?: string;
  estado: boolean;
};

async function normalizeMovement(
  movement: InventoryMovementWithRelations,
): Promise<InventoryMovementDTO> {
  const {
    tipoMovimiento,
    productos,
    cantidad,
    costoUnitario,
    bodega,
    proveedor,
  } = movement;
  const primaryDetail = productos[0];
  const product = primaryDetail?.producto;

  const { isAutoGeneratedImei } = await import("@/lib/utils-imei");
  const imeis = productos
    .map((detail) => detail.imei)
    .filter((imei): imei is string => Boolean(imei?.trim().length))
    .filter((imei) => !isAutoGeneratedImei(imei)); // Excluir IMEIs generados automáticamente

  const productLabel = product
    ? [
        product.marca?.nombre,
        product.modelo?.nombre,
        product.modelo?.almacenamiento,
        product.modelo?.color,
        product.descripcion,
      ]
        .filter(Boolean)
        .join(" ")
    : "Producto no especificado";

  const operation: MovementOperation =
    tipoMovimiento?.ingreso && !tipoMovimiento.salida ? "ingreso" : "salida";

  const unitCost = costoUnitario ? Number(costoUnitario) : 0;
  const pvp = movement.pvp ? Number(movement.pvp) : undefined;

  // Buscar si alguno de los productos está relacionado con una venta
  let ventaConsecutivo: number | undefined;
  let clienteNombre: string | undefined;

  for (const detail of productos) {
    if (detail.ventaProducto?.venta) {
      const venta = detail.ventaProducto.venta;
      ventaConsecutivo = venta.consecutivo;
      clienteNombre = venta.cliente?.nombre;
      break; // Solo necesitamos la primera venta encontrada
    }
  }

  return {
    id: movement.id,
    consecutivo: movement.consecutivo,
    typeId: movement.tipoMovimientoId ?? undefined,
    typeName: tipoMovimiento?.nombre ?? "Movimiento",
    operation,
    productId: product ? product.id : undefined,
    productLabel: productLabel.trim().length > 0 ? productLabel : "Producto",
    quantity: cantidad,
    unitCost,
    totalCost: cantidad * unitCost,
    pvp,
    imeis,
    createdAt: movement.createdAt.toISOString(),
    updatedAt: movement.updatedAt.toISOString(),
    createdBy:
      movement.creadoPor?.nombre ?? movement.creadoPor?.email ?? undefined,
    bodegaNombre: bodega?.nombre,
    proveedorNombre: proveedor?.nombre,
    ventaConsecutivo,
    clienteNombre,
    comentario: movement.comentario ?? undefined,
    estado: movement.estado,
  };
}

type NumericOperator = ">=" | "<=" | "=";

function parseNumericFilterValue(
  rawValue: string | undefined,
): { operator: NumericOperator; value: number } | null {
  if (!rawValue) return null;
  const match = rawValue.match(/^(>=|<=|=)\s*(\d+(?:\.\d*)?)$/);
  if (!match) return null;
  const numericValue = Number(match[2]);
  if (Number.isNaN(numericValue)) return null;
  return {
    operator: match[1] as NumericOperator,
    value: numericValue,
  };
}

function applyNumericFilter(
  data: InventoryMovementDTO[],
  filterValue: string | undefined,
  selector: (item: InventoryMovementDTO) => number,
): InventoryMovementDTO[] {
  const parsed = parseNumericFilterValue(filterValue);
  if (!parsed) return data;

  return data.filter((item) => {
    const candidate = selector(item);
    if (!Number.isFinite(candidate)) return false;

    switch (parsed.operator) {
      case ">=":
        return candidate >= parsed.value;
      case "<=":
        return candidate <= parsed.value;
      case "=":
        return candidate === parsed.value;
      default:
        return true;
    }
  });
}

interface ParsedDateRange {
  from?: Date;
  to?: Date;
}

const normalizeStartOfDay = (date: Date) => {
  const normalized = new Date(date);
  normalized.setHours(0, 0, 0, 0);
  return normalized;
};

const normalizeEndOfDay = (date: Date) => {
  const normalized = new Date(date);
  normalized.setHours(23, 59, 59, 999);
  return normalized;
};

const parseDateRangeFilter = (
  rawValue: string | undefined,
): ParsedDateRange | null => {
  if (!rawValue) return null;

  const [fromRaw = "", toRaw = ""] = rawValue.split("..");
  const from = fromRaw ? new Date(fromRaw) : undefined;
  const to = toRaw ? new Date(toRaw) : undefined;

  const hasValidFrom = from ? !Number.isNaN(from.getTime()) : true;
  const hasValidTo = to ? !Number.isNaN(to.getTime()) : true;

  if (!hasValidFrom || !hasValidTo) {
    return null;
  }

  return {
    from: from ? normalizeStartOfDay(from) : undefined,
    to: to ? normalizeEndOfDay(to) : undefined,
  };
};

interface GetMovementsFilters {
  movementType?: string;
  product?: string;
  operation?: MovementOperation;
  warehouse?: string;
  supplier?: string;
  user?: string;
  cliente?: string;
  imei?: string;
  comentario?: string;
  estado?: string;
  consecutive?: string;
  ventaConsecutivo?: string;
  quantity?: string;
  unitCost?: string;
  pvp?: string;
  dateRange?: string;
  updateDateRange?: string;
}

interface GetMovementsParams {
  page?: number;
  pageSize?: number;
  search?: string;
  filters?: GetMovementsFilters;
}

export interface GetInventoryMovementsSuccess {
  success: true;
  data: InventoryMovementDTO[];
  total: number;
  page: number;
  pageSize: number;
  filterOptions: Awaited<ReturnType<typeof getInventoryMovementFilterOptions>>;
}

export interface GetInventoryMovementsError {
  success: false;
  error: string;
}

export type GetInventoryMovementsResult =
  | GetInventoryMovementsSuccess
  | GetInventoryMovementsError;

export async function getInventoryMovementsAction(
  params?: GetMovementsParams,
): Promise<GetInventoryMovementsResult> {
  try {
    const page = params?.page ?? 1;
    const pageSize = params?.pageSize ?? 10;
    const offset = (page - 1) * pageSize;

    const [movements, filterOptions] = await Promise.all([
      listInventoryMovements(),
      getInventoryMovementFilterOptions(),
    ]);

    let normalized = await Promise.all(movements.map(normalizeMovement));

    if (params?.search) {
      const searchTerm = params.search.toLowerCase();
      normalized = normalized.filter((movement) => {
        const base = [
          movement.consecutivo.toString(),
          movement.typeName,
          movement.productLabel,
          movement.createdBy,
          movement.bodegaNombre,
          movement.proveedorNombre,
          ...movement.imeis,
        ]
          .filter((value): value is string => Boolean(value))
          .map((value) => value.toLowerCase());
        return base.some((value) => value.includes(searchTerm));
      });
    }

    const filters = params?.filters ?? {};

    if (filters.movementType) {
      const typeLower = filters.movementType.toLowerCase();
      normalized = normalized.filter(
        (movement) => movement.typeName.toLowerCase() === typeLower,
      );
    }

    if (filters.product) {
      const productLower = filters.product.toLowerCase();
      normalized = normalized.filter(
        (movement) => movement.productLabel.toLowerCase() === productLower,
      );
    }

    if (filters.operation) {
      normalized = normalized.filter(
        (movement) => movement.operation === filters.operation,
      );
    }

    if (filters.warehouse) {
      const warehouseLower = filters.warehouse.toLowerCase();
      normalized = normalized.filter(
        (movement) => movement.bodegaNombre?.toLowerCase() === warehouseLower,
      );
    }

    if (filters.supplier) {
      const supplierLower = filters.supplier.toLowerCase();
      normalized = normalized.filter(
        (movement) => movement.proveedorNombre?.toLowerCase() === supplierLower,
      );
    }

    if (filters.user) {
      const userLower = filters.user.toLowerCase();
      normalized = normalized.filter((movement) =>
        (movement.createdBy ?? "").toLowerCase().includes(userLower),
      );
    }

    if (filters.cliente) {
      const clienteLower = filters.cliente.toLowerCase();
      normalized = normalized.filter((movement) =>
        (movement.clienteNombre ?? "").toLowerCase().includes(clienteLower),
      );
    }

    if (filters.imei) {
      const imeiLower = filters.imei.toLowerCase();
      normalized = normalized.filter((movement) =>
        movement.imeis.some((imei) => imei.toLowerCase().includes(imeiLower)),
      );
    }

    if (filters.comentario) {
      const comentarioLower = filters.comentario.toLowerCase();
      normalized = normalized.filter((movement) =>
        (movement.comentario ?? "").toLowerCase().includes(comentarioLower),
      );
    }

    if (filters.estado) {
      const estadoBool = filters.estado === "true";
      normalized = normalized.filter(
        (movement) => movement.estado === estadoBool,
      );
    }

    normalized = applyNumericFilter(
      normalized,
      filters.consecutive,
      (movement) => movement.consecutivo,
    );

    normalized = applyNumericFilter(
      normalized,
      filters.ventaConsecutivo,
      (movement) => movement.ventaConsecutivo ?? 0,
    );

    normalized = applyNumericFilter(
      normalized,
      filters.quantity,
      (movement) => movement.quantity,
    );

    normalized = applyNumericFilter(
      normalized,
      filters.unitCost,
      (movement) => movement.unitCost,
    );

    normalized = applyNumericFilter(
      normalized,
      filters.pvp,
      (movement) => movement.pvp ?? 0,
    );

    const parsedDateRange = parseDateRangeFilter(filters.dateRange);
    const parsedUpdateDateRange = parseDateRangeFilter(filters.updateDateRange);
    if (parsedDateRange) {
      normalized = normalized.filter((movement) => {
        const createdAt = new Date(movement.createdAt);
        if (Number.isNaN(createdAt.getTime())) {
          return false;
        }

        if (parsedDateRange.from && createdAt < parsedDateRange.from) {
          return false;
        }

        if (parsedDateRange.to && createdAt > parsedDateRange.to) {
          return false;
        }

        return true;
      });
    }

    if (parsedUpdateDateRange) {
      normalized = normalized.filter((movement) => {
        const updatedAt = new Date(movement.updatedAt);
        if (Number.isNaN(updatedAt.getTime())) {
          return false;
        }

        if (
          parsedUpdateDateRange.from &&
          updatedAt < parsedUpdateDateRange.from
        ) {
          return false;
        }

        if (parsedUpdateDateRange.to && updatedAt > parsedUpdateDateRange.to) {
          return false;
        }

        return true;
      });
    }

    const total = normalized.length;
    const paginated = normalized.slice(offset, offset + pageSize);

    return {
      success: true,
      data: paginated,
      total,
      page,
      pageSize,
      filterOptions,
    };
  } catch {
    return {
      success: false,
      error: "No se pudieron obtener los movimientos de inventario",
    };
  }
}
