"use server";

import {
  getInventoryMovementFilterOptions,
  type InventoryMovementWithRelations,
  type ListMovementsPaginatedFilters,
  listInventoryMovementsPaginated,
} from "@/data/repositories/inventory.movements.repository";

export type MovementOperation = "ingreso" | "salida";

export type InventoryMovementDTO = {
  id: string;
  consecutivo: number;
  typeId?: string;
  typeName: string;
  operation: MovementOperation;
  productId?: string;
  productLabel: string;
  quantity: number;
  unitCost: number;
  totalCost: number;
  pvp?: number;
  imeis: string[];
  createdAt: string;
  updatedAt: string;
  createdBy?: string;
  bodegaNombre?: string;
  proveedorNombre?: string;
  ventaConsecutivo?: number;
  clienteNombre?: string;
  comentario?: string;
  estado: boolean;
};

async function normalizeMovement(
  movement: InventoryMovementWithRelations,
): Promise<InventoryMovementDTO> {
  const {
    tipoMovimiento,
    productos,
    cantidad,
    costoUnitario,
    bodega,
    proveedor,
  } = movement;
  const primaryDetail = productos[0];
  const product = primaryDetail?.producto;

  const { isAutoGeneratedImei } = await import("@/lib/utils-imei");
  const imeis = productos
    .map((detail) => detail.imei)
    .filter((imei): imei is string => Boolean(imei?.trim().length))
    .filter((imei) => !isAutoGeneratedImei(imei));

  const productLabel = product
    ? [
        product.marca?.nombre,
        product.modelo?.nombre,
        product.modelo?.almacenamiento,
        product.modelo?.color,
        product.descripcion,
      ]
        .filter(Boolean)
        .join(" ")
    : "Producto no especificado";

  const operation: MovementOperation =
    tipoMovimiento?.ingreso && !tipoMovimiento.salida ? "ingreso" : "salida";

  const unitCost = costoUnitario ? Number(costoUnitario) : 0;
  const pvp = movement.pvp ? Number(movement.pvp) : undefined;

  let ventaConsecutivo: number | undefined;
  let clienteNombre: string | undefined;

  for (const detail of productos) {
    if (detail.ventaProducto?.venta) {
      const venta = detail.ventaProducto.venta;
      ventaConsecutivo = venta.consecutivo;
      clienteNombre = venta.cliente?.nombre;
      break;
    }
  }

  return {
    id: movement.id,
    consecutivo: movement.consecutivo,
    typeId: movement.tipoMovimientoId ?? undefined,
    typeName: tipoMovimiento?.nombre ?? "Movimiento",
    operation,
    productId: product ? product.id : undefined,
    productLabel: productLabel.trim().length > 0 ? productLabel : "Producto",
    quantity: cantidad,
    unitCost,
    totalCost: cantidad * unitCost,
    pvp,
    imeis,
    createdAt: movement.createdAt.toISOString(),
    updatedAt: movement.updatedAt.toISOString(),
    createdBy:
      movement.creadoPor?.nombre ?? movement.creadoPor?.email ?? undefined,
    bodegaNombre: bodega?.nombre,
    proveedorNombre: proveedor?.nombre,
    ventaConsecutivo,
    clienteNombre,
    comentario: movement.comentario ?? undefined,
    estado: movement.estado,
  };
}

// ============================================
// DATE RANGE PARSING
// ============================================

const normalizeStartOfDay = (date: Date) => {
  const normalized = new Date(date);
  normalized.setHours(0, 0, 0, 0);
  return normalized;
};

const normalizeEndOfDay = (date: Date) => {
  const normalized = new Date(date);
  normalized.setHours(23, 59, 59, 999);
  return normalized;
};

interface ParsedDateRange {
  from?: Date;
  to?: Date;
}

const parseDateRangeFilter = (
  rawValue: string | undefined,
): ParsedDateRange | null => {
  if (!rawValue) return null;

  const [fromRaw = "", toRaw = ""] = rawValue.split("..");
  const from = fromRaw ? new Date(fromRaw) : undefined;
  const to = toRaw ? new Date(toRaw) : undefined;

  const hasValidFrom = from ? !Number.isNaN(from.getTime()) : true;
  const hasValidTo = to ? !Number.isNaN(to.getTime()) : true;

  if (!hasValidFrom || !hasValidTo) {
    return null;
  }

  return {
    from: from ? normalizeStartOfDay(from) : undefined,
    to: to ? normalizeEndOfDay(to) : undefined,
  };
};

// ============================================
// ACTION TYPES
// ============================================

interface GetMovementsFilters {
  movementType?: string;
  warehouse?: string;
  supplier?: string;
  user?: string;
  dateRange?: string;
}

interface GetMovementsParams {
  page?: number;
  pageSize?: number;
  search?: string;
  filters?: GetMovementsFilters;
}

export interface GetInventoryMovementsSuccess {
  success: true;
  data: InventoryMovementDTO[];
  total: number;
  page: number;
  pageSize: number;
  filterOptions: Awaited<ReturnType<typeof getInventoryMovementFilterOptions>>;
}

export interface GetInventoryMovementsError {
  success: false;
  error: string;
}

export type GetInventoryMovementsResult =
  | GetInventoryMovementsSuccess
  | GetInventoryMovementsError;

// ============================================
// MAIN ACTION - 100% DATABASE STRATEGY
// ============================================

export async function getInventoryMovementsAction(
  params?: GetMovementsParams,
): Promise<GetInventoryMovementsResult> {
  try {
    const page = params?.page ?? 1;
    const pageSize = params?.pageSize ?? 10;
    const filters = params?.filters ?? {};

    // Parse date range filter
    const parsedDateRange = parseDateRangeFilter(filters.dateRange);

    // Build repository filters
    const repoFilters: ListMovementsPaginatedFilters = {
      search: params?.search?.trim() || undefined,
      movementType: filters.movementType || undefined,
      warehouse: filters.warehouse || undefined,
      supplier: filters.supplier || undefined,
      user: filters.user || undefined,
      dateFrom: parsedDateRange?.from,
      dateTo: parsedDateRange?.to,
    };

    // Execute paginated query and filter options in parallel
    const [result, filterOptions] = await Promise.all([
      listInventoryMovementsPaginated({
        page,
        pageSize,
        filters: repoFilters,
      }),
      getInventoryMovementFilterOptions(),
    ]);

    // Normalize movements to DTOs
    const normalized = await Promise.all(result.data.map(normalizeMovement));

    return {
      success: true,
      data: normalized,
      total: result.total,
      page,
      pageSize,
      filterOptions,
    };
  } catch {
    return {
      success: false,
      error: "No se pudieron obtener los movimientos de inventario",
    };
  }
}
